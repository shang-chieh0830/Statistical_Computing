# Random number generation

## Pseudo random number generators

:::{.definition}

**PRNG**

A PRNG is an **algorithm** which outputs a sequence of numbers, which can be used as a **replacement** for an i.i.d. sequence of random numbers.

:::

### Structure of PRNG in computer

States: $s_0\xrightarrow{f} s_1 \xrightarrow{f} s_2 \xrightarrow{f} s_3 \xrightarrow{f} \dots$

Each state gives a random number :
$$s_1\xrightarrow{g}X_1\\
s_2\xrightarrow{g}X_2\\
s_3\xrightarrow{g}X_3\\
\vdots$$

where $s_i\in S.$ Here, $S$ is called the state space, $f:S\to S$ is called the mixing function and $g:S\to \mathcal R$ is called the output function.

Note that $s_0$ is never computed, $s_0$ is called the seed.


**Linear congruential generator (LCG)**

$mod \quad m$ means that we divide by m and take the remainder(對m取餘)

$X_n=a(X_{n-1}+c)\quad mod \quad m,$ where $X_n \in \{0,1,...,m-1\}, a\in \{1,2,...,m-1\}$, a is called the multiplier; $c\in \{0,1,...,m-1\}$, c is called the increment; $m\in \mathcal N=\{1,2,3,...\}$, m is called the modulus.

Under LCG, there's no difference between X and s. That is,
$X_n\in\{0,1,...,m-1\}:=S,\quad g(s)=s, \quad f(X)=(aX+c)\quad mod\quad m$

$X_0\in S$ is the seed in LCG.


:::{.example}

**LCG with $m=8, a=5, c=1, X_0=0$**

$X_1=(aX_0+c)\quad mod\quad m =(5\times 0+1)\quad mod\quad8=1$
$X_2=(aX_1+c)\quad mod\quad m =(5\times 1+1)\quad mod\quad8=6$
$X_3=(aX_2+c)\quad mod\quad m =(5\times 6+1)\quad mod\quad8=7$

```{r}
m <- 8
a <- 5
c <- 1
X0 <- 0


Xi <- X0
for (i in 1:10){
  Xi <- (a*Xi + c)%%m
  cat("X_", i, " = ", Xi, "\n", sep="")
}

```

```{r}
rLCG <- function(n, m, a, c, X0){
  Xi <- X0
  for (i in 1:n){
    Xi <- (a*Xi + c)%%m
    cat("X_", i, " = ", Xi, "\n", sep="")
  }
}

rLCG(5,8,5,1,0)
```

```{r}
rLCG <- function(n, m, a, c, X0){
  result <- numeric(n)
  Xi <- X0
  for (i in 1:n){
    Xi <- (a*Xi + c)%%m
    result[i] <- Xi
  }
  return(result)
}

rLCG(5,8,5,1,0)
```

```{r}
rLCG(16,8,5,1,0)
# Did you notice that it just repeat itself?
# This will be discuss later with the quality of PRNG
# also notice m=8, so it repeats itself every 8 numbers
```


```{r}
X <- rLCG(5,8,5,1,0)

plot(X)
```

```{r}
# the defult breaks on integer, which is not good
X <- rLCG(100000, 8,5,1,0)
hist(X) 
```


```{r}
X <- rLCG(100000, 8,5,1,0)
hist(X, breaks = seq(-0.5, 7.5, 1)) 

```

```{r}
X <- rLCG(10, 8,5,1,0)
hist(X, breaks = seq(-0.5, 7.5, 1))
```

```{r}
rLCG(10, m=2^31, a=1103515245, c=12345, X0=0)
```

:::

LCG is outdated nowadays, the purpose of introducing this method is to give you a general understanding of how pseudo random numbers are produced in computer.

```{r}
# the normal way to choose seed
?set.seed
```

```{r}
set.seed(0)
runif(3)

set.seed(1)
runif(3)
```

### Quality of PRNGs

There are a number of criteria.

1. Period Length

The computer has only finite memory, so we can't have infinite state space. It turns out that PRNG starts repeating itself after a while (entering the states that it has already visited).

The maximum period length is $|S|$.

For LCG, $S=\{0,1,...,m-1\} \implies |S|=m$

Note that random numbers never repeat, but pseudo random numbers DO!!
But fortunately, we can have extremely large period in R.

Good PRNG have large period.


2. Distribution of samples

Aim: generate uniformly distributed samples.$U(0,1)$

For LCG, $X_n \in \{0,1,...,m-1\}$, and we've seen from previous examples that LCG is indeed uniformly distributed from $\{0,1,...,m-1\}$, note that this is not $U(0,1)$ but at least it's uniformly distributed.

To get $U(0,1)$, use the transformation $U_n:=\frac{X_n+1}{m+1}\in (0,1)$ for large m.

You can use histogram or check whether the PRNG visits each state exactly once (which then produces every pseudo number once) within its maximum period length.

Better criterion: PRNG output passes statistical tests for uniform distribution w/o problems (check example 1.6 in the book)

3. Independence of samples

You can just plot $X_n$ and $X_{n-1}$ on x-axis and y-axis respectively.

```{r}
X <- rLCG(1000,8,5,1,0)
# m=8 which means small state space, you won't expect this small m gives you uniformly distributed plot

plot(X[1:999], X[2:1000])
```

```{r}
X <- rLCG(1000, m=2^32, a=1103515245, c=12345, X0=0)

plot(X[1:999], X[2:1000])
# well, it now looks like uniformly distributed
```

```{r}
U <- (X+1)/(2^32+1)
range(U)

round(range(U),4)
```

```{r}
plot(U[1:999], U[2:1000], asp=1)
# Great, U(0,1)
```

```{r}
par(mai=c(0.9,0.9,0.1,0.1))
plot(U[1:999], U[2:1000], asp=1)
```

```{r}
# Use R's default PRNG: Mersenne-Twister

X <- runif(1000)
plot(X[1:999], X[2:1000])
```

```{r}
plot(X[1:999], X[2:1000], asp=1)
# You can see there's no discernible pattern
```


In fact, the states are not independent, each state is completely determined by previous state via the function f, you can check the algorithm again. So the states are definitely not independent. But what about those outputs $X_1,X_2,...$ produced by the function g? Well, then you need to choose g properly such that g will lose some information from the states and thus make those outputs $X_1,X_2,...$ independent.

So theoretically, they are not independent unless you can choose g cleverly. 

From our scatter plots above, they actually look quite good.

:::{.definition}

**k-dimensionally equi-distributed**

A sequence of numbers is said to be k-dimensionally equidistributed if every k-tuple of possible outputs occurs equally often in this sequence.

:::

For example, consider LCG with k=2, we need to consider all pairs: (1,1), (1,2), (1,3),...

They are 2 dimensionally equi-distributed if the frequency of all possible pairs converge to the same number.

k-dimensionally equi-distributed is what we would expect for a sequence of independent random numbers.

Good PRNG has this property for large k.

4. Role of the seed

Seed will determine which of the possible output sequences of PRNG we will get.

```{r}
set.seed(1) # always get the same output
```

- Reproducible output(for reports or debugging)

- For non-reproducible output: use techniques like current time of day as the seed.

## The inverse transform method

Aim: Convert $U\sim U(0,1)$ into X from a given distribution on $\mathcal R$

:::{.definition}

The cumulative distribution function (cdf) is given by $$F(a)=P(X \le a)$$

Moreover, $$P(X\in (a,b])=P(X \le b)-P(X\le a)=F(b)-F(a)$$

:::
 

:::{.proposition}


$$U \sim U(0,1), X:=F^{-1}(u)\\
\implies X \text{ has cdf } F$$

:::

:::{.proof}

$F^{-1}(u):=inf\{x\in \mathcal R|F(x)\ge u  \}$

Let $U\sim U(0,1), X=F^{-1}(u)$. Then

$$P(X \le a)=P(F^{-1}(u)\le a)\\
=P(inf\{x\in \mathcal R | F(x)\ge u\}\le a)\\
=P(F(a)\ge u)\\
=P(u\le F(a))\\
=\frac{F(a)-0}{1-0}\\
=F(a)$$

We use the facts that $inf\{x\in \mathcal R | F(x)\ge u\}\le a\iff F(a)\ge u$ and $U\sim U(0,1)$

:::

:::{.example}

Consider $X\sim Exp(\lambda)$

$f(x)=\begin{cases} \lambda e^{-\lambda x} & x\ge 0 \\ 0 & x<0 \end{cases}$

$\implies F(a)=P(X\le a)=\int_{-\infty}^{a}f(x)dx=\int_{0}^{a}\lambda e^{-\lambda x}dx\\=(-e^{-\lambda x})|_{x=0}^{a}=-e^{-\lambda a}-(-e^{-\lambda 0})=1-e^{-\lambda a}$

$u=F(x)=1-e^{-\lambda x}\\ \iff e^{-\lambda x}=1-u \iff -\lambda x=log(1-u)\iff x=-\frac{log(1-u)}{\lambda}$


```{r}
N <- 1e5
U <- runif(N)
lambda <- 2
X <- -log(1-U)/lambda
par(mai=c(0.9, 0.9, 0.1, 0.1))
hist(X, main=NULL, prob=TRUE, breaks=50)

x <- seq(0, max(X), length.out=100)

lines(x, dexp(x, lambda), col="red")
```

:::


## Rejection sampling


### Basic Rejection Sampling

For n=1,2,3,...:
  
  Generate $X_n \sim g$ ( g is the proposal distribution) 
  
  Generate $U_n\sim U(0,1)$
  
  $$\begin{cases}output\quad X_n (accept\quad X_n), & \text{if } U_n\le p=p(X_n)\\
  ignore\quad X_n(reject \quad X_n), & o.w.\end{cases}$$ 
  
  Note that $P(U\le p)=p, \forall p\in[0,1]$, so $P(U_n\le p=p(X_n))=p=p(X_n)$, i.e. we accept $X_n$ with probability $p=p(X_n)$. Here $p(X_n)$ is to emphasize $p$ depends on $X_n$, $p(X_n)$ is not the pdf of $X_n$

  
```{r}
# first experiment about rejection sampling

N <- 10000
X <- numeric(N)
i <- 1
while (i<=N){
  Xi <- rnorm(1)

  X[i] <- Xi
  i <- i+1  
  
}

par(mai=c(0.9, 0.9, 0.1, 0.1))
hist(X, main=NULL, prob=TRUE, breaks = 50)

x <- seq(-4, 4, length.out=200)
lines(x, dnorm(x), col="red", lwd=2)
```

```{r}
N <- 10000
X <- numeric(N)
i <- 1
while (i<=N){
  Xi <- rnorm(1)
  U <- runif(1)
  p <- ifelse(Xi<0, 0.5, 1) # scale down the negative part
  if(U<=p){
    X[i] <- Xi
    i <- i+1  
  }
  
}

par(mai=c(0.9, 0.9, 0.1, 0.1))
hist(X, main=NULL, prob=TRUE, breaks = 50)

x <- seq(-4, 4, length.out=200)
lines(x, dnorm(x), col="red", lwd=2)
```

Let $\phi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$ be the std. normal pdf. 

In the above codes, `p <- ifelse(Xi<0, 0.5, 1)` scale down the negative part by `1/2`, i.e. the area under the histogram is now 1/4 (negative part) + 1/2 (positive part) = 3/4, which is no longer 1.

`p <- ifelse(Xi<0, 0.5, 1)`, you can think of this as $p(x)\phi(x)=\begin{cases} 1\phi(x), & \text{if positive part}\\ \frac{1}{2}\phi(x), & \text{if negative part}    \end{cases}$

But now, $p(x)\phi(x)$ is not a probability distribution, because the area under $p(x)\phi(x)$ is 3/4. To make this be a probability distribution again, we will divide 3/4, i.e. $\frac{1}{3/4}p(x)\phi(x)=\frac{1}{z}p(x)g(x)$, where $z=3/4, g(x)=\phi(x)$


```{r}
N <- 10000
X <- numeric(N)
i <- 1
count <- 0
while (i<=N){
  Xi <- rnorm(1)
  count <- count+1
  U <- runif(1)
  p <- ifelse(Xi<0, 0.5, 1) # scale down the negative part
  if(U<=p){
    X[i] <- Xi
    i <- i+1  
  }
  
}

# The number of required proposals we have 
# to get N accepted samples
cat("count =", count, "\n")


par(mai=c(0.9, 0.9, 0.1, 0.1))
hist(X, main=NULL, prob=TRUE, breaks = 50)

x <- seq(-4, 4, length.out=200)
lines(x, ifelse(x<0, 0.5, 1) * dnorm(x) * 4/3, col="red", lwd=2)
```

:::{.proposition}

Given proposals $X_n\sim g$, acceptance probability $p(x)\in [0,1]$

Let $N_k=$ index of the kth accepted proposal

(For example, $X_1, X_2, X_3, X_4, ...$, say $X_3$ is rejected, then $X_{N_1}=X_1, X_{N_2}=X_2, X_{N_3}=X_4,...$)


Then 

a. the accepted samples have density $$f(x)=\frac{1}{z}p(x)g(x)$$, i.e. $(X_{N_k})$ is an i.i.d. sequence with density f.

b. Each sample is accepted with probability $z$. The number of required proposals is geometrically distributed with mean $\frac{1}{z}$. 

Note that $1=\int_{\mathcal R} \frac{1}{z}p(x)g(x)dx=\frac{1}{z}\int_{\mathcal R} p(x)g(x)dx\\ \implies z=\int p(x)g(x)dx$

:::

:::{.proof}

The probability of accepting $X_n$ is 

$$P(X_n accepted)=P(U_n\le p(X_n))=\\
=\int_{\mathcal R}\int_{0}^{1}\boldsymbol 1_{\{U\le p(X)\}} du\quad g(x) dx\\
=\int_{\mathcal R}p(x)g(x)dx=z$$

Note that $p(x)=\int_{0}^{1}\boldsymbol 1_{\{U\le p(X)\}} du$ and $\boldsymbol 1_{\{U\le p(X)\}}=\begin{cases}1, & \text{if } U_n\le p(X_n)\\ 0, & o.w. \end{cases}$

Now, we want to show $P(X_{N_k}\in A)=\int_{A}f(x)dx$

$$P(X_{N_k}\in A|N_{k-1}=n)=\sum_{m=1}^{\infty}P(X_{N_k}\in A, N_k=n+m|N_{k-1}=n)\\
=\sum_{m=1}^{\infty}P(X_{N_{n+m}}\in A, N_k=n+m|N_{k-1}=n)\\
=\sum_{m=1}^{\infty}P(X_{n+m}\in A, U_{n+1}>p(X_{n+1}),...,\\ U_{n+m-1}>p(X_{n+m-1}), U_{n+m}\le p(X_{n+m})|N_{k-1}=n)\\
=\sum_{m=1}^{\infty}P(U_{n+1}>p(X_{n+1}),..., U_{n+m-1}>p(X_{n+m-1})\\, U_{n+m}\le p(X_{n+m}), X_{n+m}\in A|N_{k-1}=n)\\
=\sum_{m=1}^{\infty}P(U_{n+1}>p(X_{n+1})|N_{k-1}=n)\times \dots \times\\ P(U_{n+m-1}>p(X_{n+m-1})|N_{k-1}=n)P(X_{n+m}\in A, U_{n+m}\le p(X_{n+m})|N_{k-1}=n)$$

The last equation come about b/c of independence.


Now, observe: 

$P(U_{n+1}>p(X_{n+1})|N_{k-1}=n)=1-z$

$\vdots$

$P(U_{n+m-1}>p(X_{n+m-1})|N_{k-1}=n)=1-z$

$P(U_{n+m}\le p(X_{n+m}), X_{n+m}\in A|N_{k-1}=n)\\=\int_{\mathcal R}\int_{1}^{0}\boldsymbol 1_{\{U\le p(X), X\in A\}} du\quad g(x)dx\\=\int_{\mathcal R}\int_{1}^{0}\boldsymbol 1_{\{U\le p(X)\}}\boldsymbol 1_{\{ X\in A\}} du\quad g(x)dx\\=\int_{\mathcal R}\int_{1}^{0}\boldsymbol 1_{\{U\le p(X)\}}du\quad \boldsymbol 1_{\{ X\in A\}}g(x)dx\\=\int_{\mathcal R}p(x)\boldsymbol 1_{\{ X\in A\}}g(x)dx\\=\int_{A}p(x)g(x)dx\\$


Hence, $$P(X_{N_k}\in A|N_{k-1}=n)=\sum_{m=1}^{\infty}P(X_{N_k}\in A, N_k=n+m|N_{k-1}=n)\\
=\sum_{m=1}^{\infty}P(U_{n+1}>p(X_{n+1})|N_{k-1}=n)\times \dots \times\\ P(U_{n+m-1}>p(X_{n+m-1})|N_{k-1}=n)P(X_{n+m}\in A, U_{n+m}\le p(X_{n+m})|N_{k-1}=n)\\
= (\sum_{m=1}^{\infty}(1-z)^{m-1})\int_{A}p(x)g(x)dx\\
=(\sum_{m=0}^{\infty}(1-z)^{m})\int_{A}p(x)g(x)dx\\
=\frac{1}{1-(1-z)}\int_{A}p(x)g(x)dx\\
=\int_{A}\frac{1}{z}p(x)g(x)dx\\
=\int_{A}f(x)dx$$, which is true independent of n

Hence $P(X_{N_k}\in A)=\int_{A}f(x)dx$, i.e. $X_{N_k}$ has desity f.

Recall the fact that $\sum_{m=0}^{\infty}a^m=\frac{1}{1-a},\forall |a|<1$

:::


:::{.example}

Consider $X_n\sim U(-1,+1)\implies g(x)=\boldsymbol 1_{[-1,+1]}\times \frac{1}{2}$, and $p(x)=\sqrt{1-x^2}$, which is the upper half of the unit circle.

Then $f(x)=\frac{1}{z}p(x)g(x)=\frac{1}{z}\times \begin{cases} \sqrt{1-x^2}\times \frac{1}{2}, & \forall x\in [-1,+1]\\ 0, & \forall x \notin[-1,+1] \end{cases}$

So, $z=\int_{-1}^{+1}p(x)g(x)dx=\int_{-1}^{+1}\sqrt{1-x^2}\times 1/2dx=1/2\int_{-1}^{+1}\sqrt{1-x^2}dx\\=1/2\times \frac{1}{2}\pi1^2\\=\pi/4$

This implies the accepted samples have density
$$f(x)=\begin{cases}2/\pi\sqrt{1-x^2} & \forall x\in [-1,+1]\\0 & o.w. \end{cases}$$

In fact, this distribution f(x) is the so-called Wigner semicircle distribution.

```{r}
N <- 10000
X <- numeric(N)
i <- 1
count <- 0
while (i<=N){
  Xi <- runif(1,-1,1)
  count <- count+1
  U <- runif(1)
  p <- sqrt(1-Xi^2)
  if(U<=p){
    X[i] <- Xi
    i <- i+1  
  }
  
}

# The number of required proposals we have 
# to get N accepted samples
cat("count =", count, "\n")


par(mai=c(0.9, 0.9, 0.1, 0.1))
hist(X, main=NULL, prob=TRUE,asp=1)

x <- seq(-1, 1, length.out= 100)
f.of.x <- 4/pi * sqrt(1-x^2) * 1/2
lines(x, f.of.x, col="red", lwd=2)

```

```{r}
z=pi/4
# The number of required proposals is geometrically distributed
# with mean 1/z

1/z
```


:::
